# Power Atlas — Architecture Overview (v0.1, Draft for Discussion)

## 1) Purpose of this Architecture Overview
This document provides a shared, project-wide reference for how Power Atlas is intended to be understood during the current experimental phase. It is meant to:
- Declare and protect the project’s most important boundary: **Semantic Core vs Implementation Layer**.
- Describe conceptual layers and system boundaries at a level useful to contributors.
- Record guiding constraints (evidence, provenance, temporality, confidence) that shape future implementations.
- Establish `/docs/architecture` as the home for short, versioned architecture notes that evolve over time.

This is a **draft for discussion**, not a finalized specification.

---

## 2) Guiding Architectural Thesis (Semantic Independence)
**Primary thesis:** *The Semantic Core must remain conceptually independent from the Implementation Layer.*

Power Atlas is fundamentally a semantic system: it aims to represent meaning (ontology), claims and evidence, provenance/attribution, temporal relationships, and confidence/uncertainty. These semantic commitments should remain durable even as the project experiments with different:
- Storage engines (relational, graph, document, hybrid)
- API frameworks and service boundaries
- Query strategies and indexing approaches
- UI frameworks and visualization patterns
- Deployment and orchestration choices

**Explicit statement of independence:**
The **Semantic Core defines conceptual primitives and invariants that must remain valid regardless of how they are serialized, persisted, queried, or visualized**. Implementation details must not redefine semantics.

---

## 3) Conceptual Layering Model (Conceptual, Not Physical)
The following model describes conceptual boundaries. **During prototyping, implementations may collapse layers operationally, but conceptual boundaries remain binding.**

### A. Semantic Core (Stable / Intended to be Durable)
The Semantic Core expresses **what the system means**, not how it is stored or served. It includes:
- Ontology and conceptual primitives (e.g., entities, relationships, claims)
- Evidence-first reasoning model (claims linked to evidence)
- Provenance and attribution requirements (who/what/when/source)
- Temporal modeling assumptions (time-aware claims and relationships)
- Confidence / uncertainty representation and scoring concepts
- **Boundary: data vs interpretation** — the system models structural relationships and claims; it does **not** encode interpretations of intent, motive, or wrongdoing

**Key property:** The Semantic Core must remain portable across implementations.

### B. Infrastructure Layer (Provisional / Replaceable)
Capabilities that persist, index, and retrieve semantic information. Examples:
- Datastores (any relational/graph/document engine)
- Search/indexing systems
- File/object storage for source artifacts
- Queues, schedulers, caches
- Observability (logging, metrics, tracing)

**This layer is explicitly treated as provisional and replaceable during the experimental phase.**

### C. Interface Layer (Provisional / Replaceable)
Human- and machine-facing entry points, such as:
- APIs (REST, GraphQL, RPC, etc.)
- UI applications
- AuthN/AuthZ boundaries (as needed)
- External integration adapters

The interface should present semantic concepts without leaking infrastructure assumptions.

### D. Agent / Ingestion Layer (Provisional / Iterative)
Components that generate or enrich semantic data:
- Extraction pipelines (documents → candidate claims/evidence)
- Entity resolution / linking
- Confidence estimation and revision workflows
- Automated assistants and evaluators
- Human-in-the-loop review tools

This layer is expected to evolve rapidly, but should still produce outputs aligned with Semantic Core commitments.

---

## 4) Current Experimental Stack (Provisional, Subject to Change)
The current stack is **experimental scaffolding** used to validate the semantic approach. It should be treated as one possible implementation, not “the architecture.”

Provisional components currently in use / under exploration:
- **FastAPI** (backend service / API experimentation)
- **PostgreSQL** (relational persistence experimentation)
- **Apache AGE** (graph modeling experimentation; *not required long-term*)
- **Next.js** (UI experimentation)
- **Docker Compose** (local orchestration and developer workflow)

This list should be read as: “what we are trying right now,” not “what we have chosen.”

---

## 5) Replaceability Principle (Explicit)
Power Atlas is designed so that:
- The **Semantic Core** is the source of truth for meaning.
- The **Implementation Layer** (databases, frameworks, UI) is exchangeable.

**Stronger statement of intent:**
The system is designed such that **changing storage engines, API frameworks, or UI implementations does not require redefining semantic primitives**.

**Replaceability means:**
- We can change persistence and query strategies without altering what a claim, evidence, provenance, or temporal relationship *means*.
- We can change service frameworks without shifting semantic commitments.
- We can evolve UI/UX without distorting semantics to fit visualization constraints.

A useful review question for anything outside the Semantic Core:
> “If we replaced the database/API/UI tomorrow, would our semantic model still make sense unchanged?”

---

## 6) Architectural Constraints (Non-Negotiable Semantic Commitments)
These constraints shape design decisions across all layers. They are intentionally implementation-agnostic.

1. **Evidence-first**
   - The system prioritizes representing claims with supporting evidence, not merely storing assertions.
   - Unsupported data may exist as a hypothesis, but must be distinguishable from evidence-backed claims.

2. **Provenance-required**
   - Claims and derived conclusions must be attributable to sources (documents, datasets, humans, agents, processes).
   - The system should be able to answer: “Where did this come from?” and “How was it derived?”

3. **Time-aware**
   - Relationships and claims may change over time and must be representable as time-scoped or time-qualified.
   - The system should support reasoning like: “true as-of date X,” “superseded by later evidence,” or “valid during interval.”

4. **Confidence / uncertainty is first-class**
   - The system must support expressing confidence and ambiguity without forcing false precision.
   - Confidence should be explainable (tied to provenance/evidence and derivation process), not merely asserted.

5. **Clarity over cleverness**
   - Prefer interpretability and conceptual integrity over premature optimization or complex abstractions.

6. **Testability of semantics (independent of infrastructure)**
   - Semantic commitments should be testable without depending on a particular database, API framework, or UI.
   - This includes testing semantic invariants, provenance completeness expectations, and temporal scoping logic at the conceptual layer.

---

## 7) What this Document Does NOT Define
This draft intentionally does **not** define:
- Any database schema or specific fields
- Any database structure or graph model details
- Any internal module APIs or service boundaries
- Any API contract (routes, payloads, auth strategy)
- Any commitment to Apache AGE (or to any graph engine at all)
- Any UI information architecture or design system
- Any roadmap, timeline, or prioritization plan
- Any performance targets (beyond the general preference for clarity and correctness)

---

## 8) Open Questions & Areas for Iteration
The following are intentionally open and should evolve as prototypes teach us more:

1. **Semantic Core granularity**
   - What are the minimum stable semantic primitives we must commit to (conceptually) without becoming a schema spec?
   - **What qualifies as a semantic primitive versus an implementation artifact?**

2. **Provenance model depth**
   - What level of provenance is required for different classes of claims (manual, automated extraction, third-party datasets)?

3. **Temporal representation**
   - Which temporal patterns matter most early (as-of, interval validity, event-based timelines), and how do we keep it implementation-agnostic?

4. **Confidence semantics**
   - How do we define “confidence” conceptually (human judgment vs algorithmic scoring vs evidence-weighting) while keeping it explainable?

5. **Storage strategy exploration**
   - When do we benefit from relational-only vs graph-only vs hybrid approaches?
   - What experiments validate this without entangling semantics with storage assumptions?

6. **Interface stability vs exploration**
   - How do we enable rapid prototyping while preventing the API/UI from implicitly defining the semantics?

7. **Semantic test strategy**
   - What are the first semantic invariants and consistency checks worth encoding as tests?
   - How do we run those tests independent of infrastructure choices?

8. **Boundary enforcement**
   - What practical guardrails (documentation, code organization, tests, review checks) best prevent the Semantic Core from drifting into implementation-coupled definitions?

---

## Closing Note (Draft Status)
This v0.1 overview is a boundary declaration and modularity statement for the experimental phase. The goal is to preserve semantic durability while allowing aggressive iteration in infrastructure and interfaces. Subsequent versions should remain short, explicit about what changed, and focused on protecting the Semantic Core.
